
CLASS ENGINEX_DIJKSTRA NULL

//-------------------------------------------------------------------------------------

   VAR_START
   VAR_END

//-------------------------------------------------------------------------------------

   PUBLIC CONSTRUCT 0
   RETURN VOID

//-------------------------------------------------------------------------------------

   PUBLIC DIJKSTRADATA 2 POINTS CONNECTIONS

      DEFINE ARRAYLIST DIJKSTRADATA 0
      DEFINE ARRAYLIST SPLITTED_STRING 0
      DEFINE SORTEDLIST AVAILABLE_POINTS 0
      DEFINE SORTEDLIST AVAILABLE_CONNECTIONS 0

      FOREACH I STRING POINTS
			ENGINEX.STRINGS.EXPLODE SPLITTED_STRING 2 "#$|" "#$<&POINTS.I&>"
         IF (SPLITTED_STRING.COUNT == #i3)
            DEFINE VECTOR3 AVAILABLE_POINT 0
            AVALABLE_POINT.X = "#i<&SPLITTED_STRING.0&>"
            AVALABLE_POINT.Y = "#i<&SPLITTED_STRING.1&>"
            AVALABLE_POINT.Z = "#i<&SPLITTED_STRING.2&>"
            AVAILABLE_POINTS.ADD "AVAILABLE_POINT" "<&POINTS.I&>"
            DELETE AVAILABLE_POINT
         ENDIF
      NEXTEACH

      FOREACH I1 I ARRAYLIST CONNECTIONS
         IF ("AVAILABLE_POINTS.CONTAINS_KEY <&CONNECTIONS.GET_KEY I1&>" == TRUE)
            DEFINE ARRAYLIST AVAILABLE_POINT_CONNECTIONS 0
            FOREACH I2 STRING CONNECTIONS.I1
               IF ("AVAILABLE_POINTS.CONTAINS_KEY <&CONNECTIONS.I1&>" == TRUE)
                  AVAILABLE_POINT_CONNECTIONS.ADD "#$<&CONNECTIONS.I1&>"
               ENDIF
            NEXTEACH
            AVAILABLE_CONNECTIONS.ADD "AVAILABLE_POINT_CONNECTIONS" "<&CONNECTIONS.GET_KEY I1&>"
            DELETE AVAILABLE_POINT_CONNECTIONS
         ENDIF
      NEXTEACH

      DIJKSTRADATA.ADD "AVAILABLE_POINTS" "POINTS"
      DIJKSTRADATA.ADD "AVAILABLE_CONNECTIONS" "CONNECTIONS"

   RETURN DIJKSTRADATA

//-------------------------------------------------------------------------------------

   PUBLIC FIND_PATH 3 DIJKSTRADATA FROM TO

		DEFINE ARRAYLIST PATH 0
		IF ("DIJKSTRADATA.#$POINTS.CONTAINS_KEY <&FROM&>" == FALSE)
			RETURN PATH
		ENDIF
		IF ("DIJKSTRADATA.#$POINTS.CONTAINS_KEY <&TO&>" == FALSE)
			RETURN PATH
		ENDIF

		DEFINE ARRAYLIST CURRENT_POINTS 0
		DEFINE SORTEDLIST VISITED_POINTS 0
		CURRENT_POINTS.ADD "#$<&FROM&>"
		VISITED_POINTS.ADD #i0 "<&FROM&>"

		DEFINE INT BEST_FOUND 0
		DEFINE DOUBLE BEST_DISTANCE 0
		DEFINE STRING BEST_FROM ""
		DEFINE STRING BEST_TO ""

		DEFINE STRING CUR_POINT ""
		DEFINE STRING NEXT_POINT ""
		DEFINE DOUBLE DISTANCE 0
		DEFINE INT CUR_USED 0

		WHILE (CURRENT_POINTS.COUNT > ZERO)
			ENGINEX.MATH.MAX_DBL BEST_DISTANCE 0
			BEST_FOUND = FALSE

			FOREACH CURRENT_POINT_I STRING CURRENT_POINTS
				CUR_POINT = "#$<&CURRENT_POINTS.CURRENT_POINT_I&>"
				CUR_USED = FALSE

				FOREACH NEXT_POINT_I STRING DIJKSTRADATA.#$CONNECTIONS.CUR_POINT
					NEXT_POINT = "#$<&DIJKSTRADATA.#$CONNECTIONS.CUR_POINT.NEXT_POINT_I&>"

               IF ("VISITED_POINTS.CONTAINS_KEY <&NEXT_POINT&>" == FALSE)

                  DISTANCE DISTANCE DIJKSTRADATA.#$POINTS.CUR_POINT.X DIJKSTRADATA.#$POINTS.CUR_POINT.Y DIJKSTRADATA.#$POINTS.CUR_POINT.Z DIJKSTRADATA.#$POINTS.NEXT_POINT.X DIJKSTRADATA.#$POINTS.NEXT_POINT.Y DIJKSTRADATA.#$POINTS.NEXT_POINT.Z
                  DISTANCE = DISTANCE + "#i<&VISITED_POINTS.CUR_POINT&>"

                  IF (DISTANCE < BEST_DISTANCE)
                     BEST_DISTANCE = "#i<&DISTANCE&>"
                     BEST_FROM = "#$<&CUR_POINT&>"
                     BEST_TO = "#$<&NEXT_POINT&>"
                  ENDIF
                  CUR_USED = TRUE
                  BEST_FOUND = TRUE

               ENDIF
				NEXTEACH

				IF (CUR_USED == FALSE)
					CURRENT_POINTS.REMOVE "<&CURRENT_POINT_I&>"
					CURRENT_POINT_I = CURRENT_POINT_I - #i1
				ENDIF
			NEXTEACH

			IF (BEST_FOUND == TRUE)
				PATH_BACKWARDED.ADD "#$<&BEST_FROM&>" "<&BEST_TO&>"
				IF (BEST_TO == TO)
					CURRENT_POINTS.CLEAR
					VISITED_POINTS.CLEAR
				ELSE
					CURRENT_POINTS.ADD "#$<&BEST_TO&>"
					VISITED_POINTS.ADD "#i<&BEST_DISTANCE&>" "<&BEST_TO&>"
				ENDIF
			ENDIF
		WEND

		IF ("PATH_BACKWARDED.CONTAINS_KEY <&TO&>" == TRUE)
			DEFINE STRING BACKWARDED_POINT "<&TO&>"
			PATH.ADD "#$<&BACKWARDED_POINT&>"
			WHILE (BACKWARDED_POINT != FROM)
				BACKWARDED_POINT = "#$<&PATH_BACKWARDED.BACKWARDED_POINT&>"
				PATH.ADD "#$<&BACKWARDED_POINT&>"
			WEND
			PATH.REVERSE
		ENDIF

	RETURN PATH

//-------------------------------------------------------------------------------------

END_CLASS
